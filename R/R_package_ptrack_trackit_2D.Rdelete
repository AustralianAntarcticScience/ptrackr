###########################################################################################################################
## function to track displacement of particles along the seafloor in a ROMS-field
###########################################################################################################################

## the function needs an input for time of the model-run
## KNN can only find neighbours to multiple points but not to a single point... can this be solved? At the moment remaining point is left as floating

trackit_2D <- function(time=50){                                ## time is days
  ntime <- time*24*2                                         ## days transformation
  time_step <- 30*60                                         ## half hour time steps
  ptrack <- array(0, c(length(as.vector(pts))/2, 2, ntime))  ## create an empty array to store particle-tracks
  stopped <- rep(FALSE, length(as.vector(pts))/2)            ## create a stopping-vector
  stopindex <- rep(0, length(as.vector(pts))/2)              ## a vector to store indices of when particles stopped
  plast <- pts                                               ## copies of the starting points for updating in the loop
  pnow <- plast
  indices <- list()                                          ## store the index of the cell each pts is in fpor each time_step
  #plot(pts, pch = ".")                                      ## to plot particles after each timestep
  for (itime in seq_len(ntime)) {
    if (nrow(pts) == 1){
      message("only one point left... Now it stops, what an annoying bug: KNN$query is not able to find the nearest neighbour to a single point!")
      break
    }

    ## index 1st nearest neighbour of trace points to grid points
    dmap <- kdxy$query(plast, k = 1, eps = 0)           ## one kdtree from script "..._readit.R"
    ## store for flux-model
    indices[[itime]] <- dmap$nn.idx
    ## extract component values from the vars
    thisu <- i_u[dmap$nn.idx]                             ## u-component of ROMS
    thisv <- i_v[dmap$nn.idx]                             ## v-component of ROMS
    thish <- h[dmap$nn.idx]                               ## depth of the ROMS-cell

    ## update this time step longitude, latitude, depth
    pnow[,1] <- plast[,1] + (thisu * time_step) / (1.852 * 60 * 1000 * cos(pnow[,2] * pi/180))
    pnow[,2] <- plast[,2] + (thisv * time_step) / (1.852 * 60 * 1000)

    ## index 1st nearest neighbouring ROMS-cell to pnow
    pnowmap1 <- kdxy$query(pnow[,1:2], k = 1, eps = 0)

    ## k returns the cell-index of each point   (find the nearest grid-point from lon_u/lat_u and return its index)
    k1 <- pnowmap1$nn.idx

    ## make sure particles are not travelling upwards
    #if (depth of pnow) < (depth of plast) then assign plast to pnow with no displacement
    uphill <- h[k1] > thish +30

    pnow[uphill==TRUE,] <- plast[uphill==TRUE,]

    ## k returns the cell-index of each point at pnow (find the nearest grid-point from lon_u/lat_u and return its index)
    k2 <- kdxy$query(pnow[,1:2], k = 1, eps = 0)$nn.idx

    ## how many particles are there for each cell-index    which(tabulate(k)!=0) selects the same cells as table(k), but keeps their index
    all_dens <- tabulate(k2)

    ##########################################
    ## speed and density for each cell:
    l <- unique(k2)  #indices of each "used" cell
    #speed in active cells, needs to be in squared for equation
    cell_chars <- data.frame(cbind(l,i_u[l]^2+i_v[l]^2))
    #point-density in active cells
    cell_chars[,3] <- all_dens[l]
    #get u_div from observed and critical velocity
    U_div <- 1-(cell_chars[,2]/Ucsq)
    ##no erosion:
    U_div[U_div<0] <-0
    ## calculate number of points to settle for each cell (equation from McCave & Swift)
    cell_chars[,4] <- (testFunct(U_div,cell_chars[,3]))

    colnames(cell_chars) <- c("cell_index","velocity","n_pts_in_cell","n_pts_to_drop")

    ## stopping when outside the limits of the area
    stopped <- (pnow[,1]<=137.5 | pnow[,2]>=(-64))

    ## the quick and dirty solution
    point_chars <- data.frame(cbind(k2,cell_chars[match(k2, cell_chars[,1]),3:4]))
    point_chars[,4] <- point_chars[,3]/point_chars[,2]
    t_f <- runif(nrow(point_chars)) <= point_chars[,4]
    stopindex[(stopindex == 0 & stopped) | (stopindex == 0 & t_f)] <- itime

    ## assign stopping location of points to ptrack
    ptrack[,,itime] <- pnow
    plast <- pnow
    print(itime)
    if (all(stopindex!=0)) {
      message("exiting, all stopped")
      break
    }
  }
  ptrack <- ptrack[,,seq(itime)]
  list(ptrack = ptrack, pnow = pnow, plast = plast, stopindex = stopindex, indices = indices)
}