% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/loopit_2D3D.R
\name{loopit_2D3D}
\alias{loopit_2D3D}
\title{Loopit 2D/3D}
\usage{
loopit_2D3D(pts_seeded, romsobject, speed, runtime = 10, domain = "2D",
  looping_time = 0.25, roms_slices = 1, trajectories = FALSE)
}
\arguments{
\item{speed}{(w_sink) sinking rate m/days}

\item{runtime}{(time) total number fo days to run the model}

\item{trajectories}{TRUE/FALSE statement to define whether to store particle trajectories (model runs much faster without storing trajectories). Default is FALSE.}
}
\value{
list(pts=pts, pend=pend, stopindex=obj$stopindex, ptrack=obj$ptrack, lon_list=lon_list, idx_list=idx_list, idx_list_2D=idx_list_2D, id_list=id_list)
}
\description{
NOT WORKING YET FOR 2D, but 3D works (gives same results as "loopit")
}
\details{
Function to run the functions loopit_trackit_2D/loopit_trackit_3D to follow particles through different consecutive ROMS-sclices. Looping can also increase performance when using very large number of particles by looping through shorter time steps.
Loops are set to run in half day intervals. If no runtime is defined, the function will loop depending on the depth of the deepest cell and the sinking speed to allow each particle to possibly sink to the seafloor (2*max(h)/speed)
}
\examples{
data(surface_chl)
data(toyROMS)

########## Case 1:
pts_seeded <- create_points_pattern(surface_chl, multi=100)
run <- loopit_2D3D(pts_seeded = pts_seeded, romsobject = toyROMS, speed = 100, runtime = 50, domain = "3D", trajectories = TRUE)

## testing the output (for domain="3D")
library(rasterVis)
library(rgdal)
library(rgl)
ra <- raster(nrow=50,ncol=50,ext=extent(surface_chl))
r_roms <- rasterize(x = cbind(as.vector(toyROMS$lon_u), as.vector(toyROMS$lat_u)), y= ra, field = as.vector(-toyROMS$h))
pr <- projectRaster(r_roms, crs = "+proj=laea +lon_0=137 +lat_0=-66")  #get the right projection (through the centre)

plot3D(pr, adjust = FALSE, zfac = 50)                    # plot bathymetry with 50x exaggerated depth
pointsxy <- project(as.matrix(run$pend[,1:2]), projection(pr))  #projection on Tracking-points
points3d(pointsxy[,1],pointsxy[,2],run$pend[,3]*50)#,xlim=xlim,ylim=ylim)


########## Case 2:
pts_seeded <- create_points_pattern(surface_chl, multi=100)
run <- loopit_2D3D(pts_seeded = pts_seeded, romsobject = toyROMS, speed = 100, runtime = 50)

plot(pts_seeded)
points(run$pend, col="red", cex=0.6)
points(run$pts , col="blue", cex=0.6)







########## Case 2
## work with trajectories to get a flux (added presences/absences) of particles
run <- loopit_2D3D(pts_seeded = pts_seeded, romsobject = toyROMS, speed = 100, runtime = 50, trajectories = TRUE)
 
## THIS WAS WORKING BEFORE, only run once the functions are fixed:
## this should be abother function to handle the output
mat_list <- list()
for(islices in 1:length(run$idx_list_2D)){
  mat_list[[islices]] <- matrix(unlist(run$idx_list_2D[[islices]]),ncol=24)
}
testmatrix <- do.call(rbind, mat_list)
testid <- unlist(run$id_list)
flux_list <- split(testmatrix,testid)
for(k in 1:nrow(pts_seeded)){
  ## cells visited by a particle ("presence-only")
  flux_list[[k]] <- unique(flux_list[[k]])
  ## drop first and last value (input and setting cell)
  flux_list[[k]] <- flux_list[[k]][-c(1,length(flux_list[[k]]))]
} 
flux <- as.vector(unlist(flux_list))

}

